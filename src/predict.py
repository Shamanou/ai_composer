""" This module generates notes for a midi file using the
    trained neural network """
import pickle

import numpy
from tensorflow import keras
from util import util
from music21 import note, chord, stream, instrument, volume
import tensorflow as tf

physical_devices = tf.config.list_physical_devices('GPU')
tf.config.experimental.set_memory_growth(physical_devices[0], enable=True)
tf.config.experimental.set_memory_growth(physical_devices[1], enable=True)


def generate():
    """ Train a Neural Network to generate music """
    notes = Util.get_notes()

    # get amount of pitch names
    n_vocab = [len(set(instrument)) for instrument in notes]

    # Get all pitch names
    pitch_names = [sorted(set(item for item in instrument_in_mid)) for instrument_in_mid in notes]

    network_input = prepare_sequences(notes, pitch_names, n_vocab)
    model = create_network()
    prediction_output = generate_notes(model, network_input, pitch_names, n_vocab)
    create_midi(prediction_output)


def prepare_sequences(notes, pitch_names, n_vocab):
    """ Prepare the sequences used by the Neural Network """
    # map between notes and integers and back
    note_to_int = [dict((note, number) for number, note in enumerate(instrument)) for instrument in pitch_names]

    sequence_length = 100
    network_input = [[]] * len(n_vocab)
    output = [[]] * len(n_vocab)
    for index, note_element in enumerate(notes):
        for i in range(0, len(note_element) - sequence_length, 1):
            sequence_in = note_element[i:i + sequence_length]
            sequence_out = note_element[i + sequence_length]
            network_input[index].append([note_to_int[index][char] for char in sequence_in])
            output[index].append(note_to_int[index][sequence_out])

    network_input = numpy.array(network_input, dtype=numpy.float32)
    network_input = network_input.reshape((network_input.shape[1], network_input.shape[0], network_input.shape[2]))

    for i, vocab in enumerate(n_vocab):
        network_input[i] = network_input[i] / vocab

    return network_input


def create_network():
    """ create the structure of the neural network """
    return keras.models.load_model('../train/model', compile=True)


def generate_notes(model, network_input, pitch_names, n_vocab):
    start = numpy.random.randint(0, len(n_vocab))
    int_to_note = dict((number, note) for number, note in enumerate(pitch_names))
    pattern = network_input[start]
    prediction_output = []
    # generate 500 notes
    for note_index in range(500):
        if pattern.size > 0:
            prediction_input = numpy.reshape(pattern, (1, 100, len(n_vocab)))
            prediction_input = numpy.array(prediction_input, dtype=numpy.float32)
            for i, vocab in enumerate(n_vocab):
                network_input[i] = network_input[i] / vocab + 1
            prediction = model.predict(prediction_input, verbose=0)[0]
            prediction = numpy.array(prediction, dtype=numpy.str)
            prediction = prediction.reshape((prediction.shape[1], -1))

            for i in range(146):
                index = numpy.argmax(prediction[i])
                result = int_to_note[index]
                prediction_output.append(result)
                numpy.append(pattern, index)
                pattern = pattern[1:pattern.shape[0]]

    offset = 0
    output_notes = []
    # create note and chord objects based on the values generated by the model
    for p in prediction_output:
        # pattern is a chord
        for pattern in p:
            if ('.' in pattern) or pattern.isdigit():
                notes_in_chord = pattern.split('.')
                notes = []
                for current_note in notes_in_chord:
                    new_note = note.Note(int(current_note))
                    new_note.storedInstrument = instrument.Piano()
                    notes.append(new_note)
                new_chord = chord.Chord(notes)
                new_chord.offset = offset
                output_notes.append(new_chord)
            # pattern is a note
            else:
                new_note = note.Note(pattern)
                new_note.offset = offset
                new_note.storedInstrument = instrument.Piano()
                output_notes.append(new_note)
            # increase offset each iteration so that notes do not stack
            offset += 0.5

    return output_notes


def create_midi(prediction_output):
    """ convert the output from the prediction to notes and create a midi file
        from the notes """
    offset = 0
    output_notes = []

    with open('../data/instruments', 'rb') as file_handle:
        instruments = pickle.load(file_handle)

        # create note and chord objects based on the values generated by the model
        for prediction in prediction_output:
            for index, pattern in enumerate(prediction):
                # pattern is a chord
                if ('.' in pattern) or pattern.isdigit():
                    notes_in_chord = pattern.split('.')
                    notes = []
                    for current_note in notes_in_chord:
                        new_note = note.Note(int(current_note))
                        new_note.storedInstrument = instruments[index]
                        notes.append(new_note)
                    new_chord = chord.Chord(notes)
                    new_chord.offset = offset
                    output_notes.append(new_chord)
                # pattern is a note
                else:
                    new_note = note.Note(pattern)
                    new_note.offset = offset
                    new_note.storedInstrument = instruments[index]
                    output_notes.append(new_note)

            # increase offset each iteration so that notes do not stack
            offset += 0.5

        midi_stream = stream.Stream(output_notes).chordify()
        midi_stream.write('midi', fp='test_output.mid')


generate()
